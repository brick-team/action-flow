# 函数调度器初稿设计说明


## 项目背景
在日常开发过程中经常会遇到频繁修改接口的功能，例如原始系统中只有用户登录，经过项目迭代需要增加登陆发放积分的功能，对于这样的需求变化常见的是通过修改原本的登陆接口，在登陆完成后执行发放积分的操作。再经过迭代登陆发放积分操作停止了，对于这样的修改又需要在原有登陆接口中将发放积分的操作删除。本项目旨在通过配置完成上述操作。



## 设计说明

初稿阶段只支持Java基础类型作为参数的函数调用。

在常规项目开发中对于函数的执行一般有如下几种。

1. 执行函数所需的参数。
2. 函数本身的定义。
3. 函数处理结果。
4. 对函数处理结果的处理。

根据上述四种分类可以做出核心数据结构抽象。

1. 表示参数的Param
2. 表示函数的Action
3. 表示数据监控的Watcher
4. 表示数据提取器的Extract
5. 表示流程的Flow，在流程中的工作节点Work

接下来使用XML的形式对核心数据结构进行设计，首先是Param数据结构的设计，XML定义如下。

```xml
<params>
  <param group="a">
    <key>username</key>
    <value>username</value>
  </param>

  <param group="a">
    <key>password</key>
    <value>password</value>
  </param>
</params>
```

对于单个param节点的表示需要有三个核心数据。

1. group：表示分组
2. key：表示方法参数名称
3. value：表示执行方法时需要的参数

其次是Action数据结构的设计，XML定义如下。

```xml
<actions>
  <action id="login" class="LoginAction" method="login">
    <param index="0" arg_name="username" param_group="a" ex="username"
           type="java.lang.String"/>
    <param index="1" arg_name="password" param_group="a" ex="password"
           type="java.lang.String"></param>
  </action>
  <action id="sendPoint" class="SendPointAction"
          method="sendPoint">
    <param index="0" arg_name="uid" param_group="a" ex="username" type="java.lang.String">
    </param>
    <param index="1" arg_name="point" value="10" type="java.lang.Integer">
      <format id="f1" class="StringToIntegerFormat"></format>
    </param>
  </action>
</actions>
```

对于单个Action节点组成结构有三部分。

1. action节点本身包含三个数据。
   1. id：动作id，当前xml唯一。
   2. class：类名称。
   3. method：方法名称
2. 参数节点本身包含如下数据
   1. index：参数位置。
   2. arg_name：参数名称。
   3. param_group：表示参数组别，数据需要与param节点中的group对应。
   4. ex：表示参数组别中的提取key，
   5. type：表示参数类型。
3. 转换器节点有如下两部分组成。
   1. id：序号，当前xml唯一。
   2. class：类，必须实现Format接口。

通过action+param+format节点可以完成java函数的定义以及执行阶段的参数转换。

接下来对Watcher结构进行设计说明，XML表述如下

```xml
<watchers>
  <watcher id="w1" exid="e3" condition="> 10">
    <then actionId="sendPoint"/>
    <catch actionId="sendPoint"/>
  </watcher>
</watchers>

```

watcher节点由三部分组成。

1. 节点数据本身。
   1. id：序号。
   2. exid：提取器id，必须是extracts节点下的数据
   3. condition：条件表达式
2. then节点，属性值actionId表示动作id，当提取器提取的数据结果符合条件表达式执行
3. catch节点，属性值actionId表示动作id，当提取器提取的数据结果不符合条件表达式执行



接下来对Result结构进行设计说明，XML表述如下

```xml
<result>
  <key name="r1" exid="e1"/>
  <key name="r2" exid="e2"/>
</result>
```

result节点由多个key节点组成，单个key节点数据包含两个。

1. name：名称。返回结构json中的key。
2. exid：提取器id

接下来对extracts结构进行设计说明，XML表述如下

```xml
<extracts>
  <extract id="e1" fromAction="login" el="$.username"/>
  <extract id="e2" fromAction="login" el="$.login_time"/>
  <extract id="e3" fromAction="login" el="$.age"/>
</extracts>
```

extract节点数据有三个分别是。

1. id：提取器编号，全局唯一。
2. fromAction：执行器id，表示从哪个执行器中获取结果。
3. el：提取器表达式，需要符合json-path的解析规则。

最后对flow结构进行设计说明，XML表述如下

```xml
<flow id="1">
  <work id="work1" type="action" ref_id="login">
    <catch>
      <work id="work2" type="watcher" ref_id="w1">
      </work>
    </catch>
    <then>
      <work id="work2" type="watcher" ref_id="w1">
        <then>
          <work id="work3" type="watcher" ref_id="w1"/>
        </then>
      </work>
    </then>
  </work>
</flow>

```

flow节点由work、then、catch节点组成，work节点包含三个数据信息。

1. id：工作id，该属性可以暂时不填写，
2. type：工作类型，存在两个action和watcher
3. ref_id：外联id，寻找对应的action或者watcher

catch表示在work执行失败后执行的内容，then表示在work执行成功之后执行的内容。执行内容是work节点允许存在多个。





核心执行流程依靠flow节点进行。执行流程简单理解如下。

1. 找到work类型对应的执行器（action或者watcher）。
2. 执行执行器。
3. 确认执行器执行是否正常。
4. 如果正常走then
5. 如果异常走catch

上述流程支持嵌套。

